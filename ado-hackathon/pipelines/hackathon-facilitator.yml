# Azure DevOps AI Agent Deployment Hackathon Facilitator
# 
# This pipeline manages the entire hackathon experience for deploying AI agents:
# 1. Initial run (manual): Creates Epic and Step 1 work item
# 2. Subsequent runs (automatic): Detects step completion and creates next work items
#
# Teaches students to deploy AI agents using pipelines in /cicd folder

trigger:
  branches:
    include:
      - main
  # Trigger on ANY push to main branch to detect step completions
  # The pipeline itself checks for completion marker files

pr: none

pool:
  vmImage: 'ubuntu-latest'

variables:
  System.Debug: false

stages:
- stage: InitializeOrProgress
  displayName: 'Hackathon Facilitator'
  jobs:
  - job: ManageHackathon
    displayName: 'Initialize or Progress Hackathon'
    steps:
    - checkout: self
      clean: true

    - task: PowerShell@2
      displayName: 'Hackathon Facilitator'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "##[section]Azure DevOps CI/CD Hackathon Facilitator"
          Write-Host "This pipeline manages your hackathon progress automatically!"
          Write-Host ""
          
          $token = "$(System.AccessToken)"
          $encodedToken = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(":$token"))
          $headers = @{
              Authorization = "Basic $encodedToken"
              "Content-Type" = "application/json-patch+json"
          }
          
          $orgUrl = "$(System.CollectionUri)"
          $projectName = "$(System.TeamProject)"
          $apiVersion = "7.1"
          
          # Helper function to convert Markdown to HTML for Azure DevOps work items
          function Convert-MarkdownToHtml {
              param([string]$Markdown)
              
              $html = $Markdown
              
              # Handle collapsible sections (details/summary) - MUST be before other processing
              # Pattern: <details>\n<summary>Title</summary>\n\ncontent\n</details>
              $html = [regex]::Replace($html, '<details>\s*<summary>([^<]+)</summary>', '<div style="border:1px solid #ddd;border-radius:4px;margin:10px 0;"><div style="background:#f0f0f0;padding:8px;cursor:pointer;font-weight:bold;">ðŸ“Œ $1 (click to expand)</div><div style="padding:10px;display:block;">')
              $html = $html -replace '</details>', '</div></div>'
              
              # Handle fenced code blocks with language (```yaml, ```bash, etc.)
              $html = [regex]::Replace($html, '```(\w+)\r?\n([\s\S]*?)```', '<pre style="background-color:#f4f4f4;padding:10px;border-radius:4px;overflow-x:auto;font-family:monospace;"><code>$2</code></pre>')
              
              # Handle fenced code blocks without language
              $html = [regex]::Replace($html, '```\r?\n([\s\S]*?)```', '<pre style="background-color:#f4f4f4;padding:10px;border-radius:4px;overflow-x:auto;font-family:monospace;"><code>$1</code></pre>')
              
              # Handle inline code
              $html = [regex]::Replace($html, '`([^`]+)`', '<code style="background-color:#f4f4f4;padding:2px 5px;border-radius:3px;font-family:monospace;">$1</code>')
              
              # Handle markdown tables - convert to HTML tables
              # First, identify table rows (lines starting with |)
              $tablePattern = '(?m)(^\|.+\|\r?\n)+'
              $html = [regex]::Replace($html, $tablePattern, {
                  param($match)
                  $tableContent = $match.Value
                  $rows = $tableContent -split '\r?\n' | Where-Object { $_ -match '^\|' }
                  $htmlTable = '<table style="border-collapse:collapse;width:100%;margin:10px 0;">'
                  $isHeader = $true
                  foreach ($row in $rows) {
                      # Skip separator row (|---|---|)
                      if ($row -match '^\|[\s\-:]+\|$') { continue }
                      if ($row -match '^\|(\s*[-:]+\s*\|)+$') { continue }
                      
                      $cells = $row -split '\|' | Where-Object { $_.Trim() -ne '' }
                      if ($isHeader) {
                          $htmlTable += '<tr style="background:#f0f0f0;">'
                          foreach ($cell in $cells) {
                              $htmlTable += "<th style='border:1px solid #ddd;padding:8px;text-align:left;'>$($cell.Trim())</th>"
                          }
                          $htmlTable += '</tr>'
                          $isHeader = $false
                      } else {
                          $htmlTable += '<tr>'
                          foreach ($cell in $cells) {
                              $htmlTable += "<td style='border:1px solid #ddd;padding:8px;'>$($cell.Trim())</td>"
                          }
                          $htmlTable += '</tr>'
                      }
                  }
                  $htmlTable += '</table>'
                  return $htmlTable
              })
              
              # Handle headers
              $html = [regex]::Replace($html, '^#### (.+)$', '<h4 style="color:#333;margin-top:15px;">$1</h4>', 'Multiline')
              $html = [regex]::Replace($html, '^### (.+)$', '<h3 style="color:#333;margin-top:20px;">$1</h3>', 'Multiline')
              $html = [regex]::Replace($html, '^## (.+)$', '<h2 style="color:#0066cc;margin-top:25px;border-bottom:1px solid #eee;padding-bottom:5px;">$1</h2>', 'Multiline')
              $html = [regex]::Replace($html, '^# (.+)$', '<h1 style="color:#0066cc;">$1</h1>', 'Multiline')
              
              # Handle bold and italic
              $html = [regex]::Replace($html, '\*\*\*(.+?)\*\*\*', '<strong><em>$1</em></strong>')
              $html = [regex]::Replace($html, '\*\*(.+?)\*\*', '<strong>$1</strong>')
              $html = [regex]::Replace($html, '\*(.+?)\*', '<em>$1</em>')
              
              # Handle links
              $html = [regex]::Replace($html, '\[([^\]]+)\]\(([^)]+)\)', '<a href="$2" style="color:#0066cc;">$1</a>')
              
              # Handle horizontal rules
              $html = [regex]::Replace($html, '^---+$', '<hr style="border:none;border-top:1px solid #ddd;margin:20px 0;"/>', 'Multiline')
              
              # Handle unordered lists (- item)
              $html = [regex]::Replace($html, '(?m)^- (.+)$', '<li style="margin:5px 0;">$1</li>')
              $html = [regex]::Replace($html, '(<li[^>]*>.*</li>)(\r?\n<li)', '$1$2')
              
              # Handle checkbox lists
              $html = $html -replace '\[ \]', 'â˜'
              $html = $html -replace '\[x\]', 'â˜‘'
              $html = $html -replace '\[X\]', 'â˜‘'
              
              # Handle numbered lists
              $html = [regex]::Replace($html, '(?m)^\d+\. (.+)$', '<li style="margin:5px 0;">$1</li>')
              
              # Handle blockquotes
              $html = [regex]::Replace($html, '(?m)^> (.+)$', '<blockquote style="border-left:4px solid #0066cc;padding-left:15px;margin:10px 0;color:#555;background:#f9f9f9;">$1</blockquote>')
              
              # Convert remaining newlines to <br/>
              $html = $html -replace '\r?\n', '<br/>'
              
              # Clean up excessive <br/> tags
              $html = [regex]::Replace($html, '(<br/>){3,}', '<br/><br/>')
              $html = $html -replace '<h(\d)([^>]*)><br/>', '<h$1$2>'
              $html = $html -replace '<br/></h(\d)>', '</h$1>'
              $html = $html -replace '</pre><br/>', '</pre>'
              $html = $html -replace '<br/><pre', '<pre'
              $html = $html -replace '</li><br/>', '</li>'
              $html = $html -replace '<br/><li>', '<li>'
              $html = $html -replace '</blockquote><br/>', '</blockquote>'
              $html = $html -replace '<hr[^>]*><br/>', '<hr style="border:none;border-top:1px solid #ddd;margin:20px 0;"/>'
              $html = $html -replace '</table><br/>', '</table>'
              $html = $html -replace '<br/><table', '<table'
              $html = $html -replace '</div></div><br/>', '</div></div>'
              
              return $html
          }
          
          # Helper function to create work items with type detection
          function Create-WorkItem {
              param(
                  [string]$Title,
                  [string]$Description,
                  [string]$ParentId = $null
              )
              
              Write-Host "Creating work item: $Title"
              
              # Try each work item type until one succeeds
              $workItemTypes = @("User Story", "Product Backlog Item", "Issue", "Requirement")
              $created = $false
              
              foreach ($workItemType in $workItemTypes) {
                  try {
                      $workItemBody = @(
                          @{
                              op = "add"
                              path = "/fields/System.Title"
                              value = $Title
                          },
                          @{
                              op = "add"
                              path = "/fields/System.Description"
                              value = $Description
                          }
                      )
                      
                      if ($ParentId) {
                          $workItemBody += @{
                              op = "add"
                              path = "/relations/-"
                              value = @{
                                  rel = "System.LinkTypes.Hierarchy-Reverse"
                                  url = "${orgUrl}_apis/wit/workitems/${ParentId}"
                              }
                          }
                      }
                      
                      $body = ConvertTo-Json -InputObject $workItemBody -Depth 10
                      $createUrl = "${orgUrl}${projectName}/_apis/wit/workitems/`$$workItemType`?api-version=$apiVersion"
                      
                      $response = Invoke-RestMethod -Uri $createUrl -Method Post -Headers $headers -Body $body
                      Write-Host "âœ… Created work item #$($response.id) (Type: $workItemType)"
                      return $response.id
                  }
                  catch {
                      Write-Host "Could not create with type '$workItemType', trying next..."
                  }
              }
              
              Write-Host "##[error]Failed to create work item with any type"
              return $null
          }
          
          # Helper function to close work item
          function Close-WorkItem {
              param([string]$WorkItemId)
              
              Write-Host "Marking work item #$WorkItemId as complete..."
              
              # Try to change state first
              $statesToTry = @("Done", "Closed", "Resolved")
              $stateChanged = $false
              
              foreach ($state in $statesToTry) {
                  $closeBody = @(
                      @{
                          op = "add"
                          path = "/fields/System.State"
                          value = $state
                      }
                  ) | ConvertTo-Json -Depth 10
                  
                  $closeUrl = "${orgUrl}${projectName}/_apis/wit/workitems/${WorkItemId}?api-version=$apiVersion"
                  
                  try {
                      Invoke-RestMethod -Uri $closeUrl -Method Patch -Headers $headers -Body $closeBody | Out-Null
                      Write-Host "âœ… Work item #$WorkItemId marked as $state"
                      $stateChanged = $true
                      break
                  }
                  catch {
                      # Try next state
                  }
              }
              
              if (-not $stateChanged) {
                  Write-Host "##[warning]Could not change state, adding completion tag instead..."
                  # Add a tag to mark as complete
                  $tagBody = @(
                      @{
                          op = "add"
                          path = "/fields/System.Tags"
                          value = "Completed"
                      }
                  ) | ConvertTo-Json -Depth 10
                  
                  try {
                      Invoke-RestMethod -Uri $closeUrl -Method Patch -Headers $headers -Body $tagBody | Out-Null
                      Write-Host "âœ… Added 'Completed' tag to work item #$WorkItemId"
                  }
                  catch {
                      Write-Host "##[warning]Could not update work item #$WorkItemId at all (permissions issue)"
                  }
              }
          }
          
          # Helper function to find work item by title
          function Find-WorkItem {
              param(
                  [string]$TitlePattern,
                  [switch]$ExactMatch
              )
              
              $whereClause = if ($ExactMatch) {
                  "[System.Title] = '$TitlePattern'"
              } else {
                  "[System.Title] CONTAINS '$TitlePattern'"
              }
              
              $wiql = @{
                  query = "SELECT [System.Id], [System.State], [System.Title], [System.Tags] FROM WorkItems WHERE $whereClause AND [System.TeamProject] = '$projectName' ORDER BY [System.CreatedDate] DESC"
              } | ConvertTo-Json
              
              $wiqlUrl = "${orgUrl}${projectName}/_apis/wit/wiql?api-version=$apiVersion"
              
              try {
                  $queryResult = Invoke-RestMethod -Uri $wiqlUrl -Method Post -Headers $headers -Body $wiql -ContentType "application/json"
                  
                  if ($queryResult.workItems -and $queryResult.workItems.Count -gt 0) {
                      $workItemId = $queryResult.workItems[0].id
                      
                      # Get work item details
                      $wiUrl = "${orgUrl}${projectName}/_apis/wit/workitems/${workItemId}?api-version=$apiVersion"
                      $wi = Invoke-RestMethod -Uri $wiUrl -Method Get -Headers $headers
                      
                      return @{
                          Id = $workItemId
                          State = $wi.fields.'System.State'
                          Title = $wi.fields.'System.Title'
                          Tags = $wi.fields.'System.Tags'
                      }
                  }
              }
              catch {
                  Write-Host "Could not query work item: $_"
              }
              
              return $null
          }
          
          Write-Host "##[section]Step 1: Check if hackathon is initialized"
          
          # Check if Epic exists
          $epic = Find-WorkItem -TitlePattern "AI Agent Deployment Hackathon"
          
          if (-not $epic) {
              Write-Host "ðŸŽ¯ First time run - Initializing hackathon!"
              Write-Host ""
              
              # Create Epic work item
              Write-Host "##[section]Creating Parent Epic"
              $epicDescription = @"
          <h1>Welcome to the AI Agent Deployment Hackathon! ðŸ¤–ðŸš€</h1>
          <p>This Epic tracks your progress through all 6 steps of learning to deploy AI agents with Azure DevOps CI/CD.</p>
          <p><strong>ðŸ“‹ Prerequisites:</strong> Before starting, deploy Azure AI resources using the terraform scripts in the <code>/terraform</code> folder. See the README for instructions.</p>
          <h2>Your Journey:</h2>
          <ol>
          <li>Configure Azure DevOps (Service Connections, Variable Groups, Environments)</li>
          <li>Create Agent Creation Pipeline (cicd/createagentpipeline.yml)</li>
          <li>Deploy Agents Across Environments (Dev â†’ Test â†’ Prod)</li>
          <li>Create Testing Pipeline (cicd/agentconsumptionpipeline.yml)</li>
          <li>Run Agent Evaluation (AI Quality Metrics)</li>
          <li>Security & Red Team Testing (Security Assessment)</li>
          </ol>
          <p><strong>What you'll learn:</strong> Deploy AI agents, CI/CD pipelines, multi-environment promotion, AI evaluation, and security testing!</p>
          <p><strong>How it works:</strong> Complete each step, push your changes, and the facilitator pipeline will automatically create the next work item!</p>
          <p>Good luck! ðŸŽ‰</p>
          "@
              
              $epicId = Create-WorkItem -Title "ðŸ¤– AI Agent Deployment Hackathon - Progress Tracker" -Description $epicDescription
              
              if (-not $epicId) {
                  Write-Host "##[error]Failed to create Epic work item"
                  exit 1
              }
              
              Write-Host ""
              Write-Host "##[section]Creating Step 1 Work Item"
              
              # Check if Step 1 already exists
              $existingStep1 = Find-WorkItem -TitlePattern "Step 1: Configure Azure DevOps for AI Agent Deployment" -ExactMatch
              if ($existingStep1) {
                  Write-Host "##[warning]Step 1 work item already exists (#$($existingStep1.Id)). Skipping creation."
                  Write-Host ""
                  Write-Host "ðŸŽ¯ Work item #$($existingStep1.Id) is ready. Start working on Step 1!"
                  exit 0
              }
              
              # Read Step 1 instructions
              $step1Path = "$(Build.SourcesDirectory)/ado-hackathon/work-items/step-1-azure-devops.md"
              if (Test-Path $step1Path) {
                  $step1Content = Get-Content $step1Path -Raw
                  $step1Html = Convert-MarkdownToHtml -Markdown $step1Content
              } else {
                  $step1Html = "<p>See ado-hackathon/work-items/step-1-azure-devops.md for instructions</p>"
              }
              
              $step1Id = Create-WorkItem -Title "Step 1: Configure Azure DevOps for AI Agent Deployment" -Description $step1Html -ParentId $epicId
              
              if ($step1Id) {
                  Write-Host ""
                  Write-Host "##[section]âœ… Hackathon Initialized Successfully!"
                  Write-Host ""
                  Write-Host "ðŸŽ¯ Next steps:"
                  Write-Host "   1. Go to Boards â†’ Work Items"
                  Write-Host "   2. Open Step 1 work item #$step1Id"
                  Write-Host "   3. Follow the instructions"
                  Write-Host "   4. Push your changes when done"
                  Write-Host "   5. This pipeline will automatically create Step 2!"
                  Write-Host ""
              } else {
                  Write-Host "##[error]Failed to create Step 1 work item"
                  exit 1
              }
              
              exit 0
          }
          
          Write-Host "âœ… Hackathon already initialized (Epic #$($epic.Id) found)"
          Write-Host ""
          
          # Define step detection rules for AI agent deployment hackathon
          $steps = @(
              @{
                  Number = 1
                  Title = "Step 1: Configure Azure DevOps for AI Agent Deployment"
                  SearchPattern = "Step 1"
                  NextTitle = "Step 2: Build Your Agent Deployment Pipeline ðŸŽ“"
                  Files = @("azure-devops-config.md")
                  WorkItemFile = "step-2-create-agent-pipeline.md"
              },
              @{
                  Number = 2
                  Title = "Step 2: Build Your Agent Deployment Pipeline ðŸŽ“"
                  SearchPattern = "Step 2"
                  NextTitle = "Step 3: Run Pipeline & Deploy Agents ðŸš€"
                  Files = @("pipeline-1-created.md")
                  WorkItemFile = "step-3-deploy-agents.md"
              },
              @{
                  Number = 3
                  Title = "Step 3: Run Pipeline & Deploy Agents ðŸš€"
                  SearchPattern = "Step 3"
                  NextTitle = "Step 4: Build Your Testing Pipeline ðŸ§ª"
                  Files = @("agents-deployed.md")
                  WorkItemFile = "step-4-create-testing-pipeline.md"
              },
              @{
                  Number = 4
                  Title = "Step 4: Build Your Testing Pipeline ðŸ§ª"
                  SearchPattern = "Step 4"
                  NextTitle = "Step 5: Run Evaluation & Review Metrics ðŸ“Š"
                  Files = @("pipeline-2-created.md")
                  WorkItemFile = "step-5-run-evaluation.md"
              },
              @{
                  Number = 5
                  Title = "Step 5: Run Evaluation & Review Metrics ðŸ“Š"
                  SearchPattern = "Step 5"
                  NextTitle = "Step 6: Security Red Team Analysis ðŸ”’"
                  Files = @("evaluation-complete.md")
                  WorkItemFile = "step-6-security-redteam.md"
              },
              @{
                  Number = 6
                  Title = "Step 6: Security Red Team Analysis ðŸ”’"
                  SearchPattern = "Step 6"
                  NextTitle = $null
                  Files = @("hackathon-complete.md")
                  WorkItemFile = $null
              }
          )
          
          Write-Host "##[section]Step 2: Check for completed steps"
          Write-Host ""
          
          # FILE-BASED APPROACH: Use file existence as the source of truth
          # This allows users to start where they left off regardless of work item state
          
          Write-Host "Scanning completion files to determine progress..."
          Write-Host ""
          
          # First, determine which step the user is currently on based on files
          $currentStepNumber = 1  # Default to step 1
          
          foreach ($step in $steps) {
              $filesExist = $false
              foreach ($file in $step.Files) {
                  $fullPath = "$(Build.SourcesDirectory)/$file"
                  if (Test-Path $fullPath) {
                      $filesExist = $true
                      Write-Host "  âœ… Step $($step.Number) complete: Found $file"
                      break
                  }
              }
              
              if ($filesExist) {
                  # This step is complete, move to next
                  $currentStepNumber = $step.Number + 1
              } else {
                  # This step is not complete - this is where user should be
                  Write-Host "  ðŸ“‹ Step $($step.Number) in progress: Waiting for $($step.Files -join ' or ')"
                  break
              }
          }
          
          Write-Host ""
          
          # Check if all steps are complete
          if ($currentStepNumber -gt $steps.Count) {
              Write-Host "##[section]ðŸŽ‰ðŸŽ‰ðŸŽ‰ CONGRATULATIONS! ðŸŽ‰ðŸŽ‰ðŸŽ‰"
              Write-Host ""
              Write-Host "You've completed ALL 6 steps of the AI Agent Deployment Hackathon!"
              Write-Host ""
              Write-Host "You've learned:"
              Write-Host "  âœ… Azure DevOps service connections and variable groups"
              Write-Host "  âœ… CI/CD pipelines for AI agent deployment"
              Write-Host "  âœ… Multi-environment agent deployments (dev/test/prod)"
              Write-Host "  âœ… AI agent testing and evaluation"
              Write-Host "  âœ… AI quality metrics and evaluation"
              Write-Host "  âœ… Security testing and red team analysis"
              Write-Host ""
              Write-Host "You're now ready to deploy AI agents in production! ðŸ¤–ðŸš€"
              exit 0
          }
          
          $currentStep = $steps | Where-Object { $_.Number -eq $currentStepNumber }
          Write-Host "##[section]Current Step: $currentStepNumber - $($currentStep.Title)"
          Write-Host ""
          
          # Check if work item exists for current step
          $workItem = Find-WorkItem -TitlePattern $currentStep.Title -ExactMatch
          
          if ($workItem) {
              Write-Host "âœ… Work item #$($workItem.Id) already exists for Step $currentStepNumber"
              Write-Host ""
              Write-Host "ðŸŽ¯ Continue working on Step $currentStepNumber!"
              Write-Host "   Required file: $($currentStep.Files -join ' or ')"
              Write-Host "   When complete, commit and push to main branch."
              exit 0
          }
          
          # Work item doesn't exist - create it
          Write-Host "Creating work item for Step $currentStepNumber..."
          
          # Determine which markdown file to use for the work item description
          $workItemFile = "step-$currentStepNumber-*.md"
          $workItemPath = Get-ChildItem -Path "$(Build.SourcesDirectory)/ado-hackathon/work-items/" -Filter "step-$currentStepNumber-*.md" | Select-Object -First 1
          
          if ($workItemPath) {
              Write-Host "  Loading description from: $($workItemPath.Name)"
              $content = Get-Content $workItemPath.FullName -Raw
              $html = Convert-MarkdownToHtml -Markdown $content
          } else {
              $html = "<p>See ado-hackathon/work-items/ for Step $currentStepNumber instructions</p>"
          }
          
          $newWorkItemId = Create-WorkItem -Title $currentStep.Title -Description $html -ParentId $epic.Id
          
          if ($newWorkItemId) {
              Write-Host ""
              Write-Host "##[section]âœ… Work Item Created!"
              Write-Host ""
              Write-Host "  Step: $currentStepNumber"
              Write-Host "  Work Item: #$newWorkItemId"
              Write-Host "  Title: $($currentStep.Title)"
              Write-Host ""
              Write-Host "ðŸŽ¯ Next Steps:"
              Write-Host "  1. Go to Boards â†’ Work Items"
              Write-Host "  2. Open work item #$newWorkItemId"
              Write-Host "  3. Follow the instructions"
              Write-Host "  4. Create the required file: $($currentStep.Files -join ' or ')"
              Write-Host "  5. Commit and push to main branch"
              Write-Host ""
          } else {
              Write-Host "##[warning]Could not create work item, but you can still proceed!"
              Write-Host "  Follow instructions in: ado-hackathon/work-items/step-$currentStepNumber-*.md"
          }
          
          # Also close any previous step work items that are complete
          Write-Host ""
          Write-Host "Checking for completed steps to close..."
          for ($i = 1; $i -lt $currentStepNumber; $i++) {
              $prevStep = $steps | Where-Object { $_.Number -eq $i }
              $prevWorkItem = Find-WorkItem -TitlePattern $prevStep.Title -ExactMatch
              if ($prevWorkItem -and $prevWorkItem.State -ne "Done" -and $prevWorkItem.State -ne "Closed" -and $prevWorkItem.State -ne "Resolved") {
                  Write-Host "  Closing Step $i work item #$($prevWorkItem.Id)..."
                  Close-WorkItem -WorkItemId $prevWorkItem.Id
              }
          }
          
          Write-Host ""
          Write-Host "##[section]Hackathon Facilitator Complete âœ…"
